# Encapsulation and Data Hiding

::: {.notes}
Welcome to our session on Encapsulation and Data Hiding in Python. Today, we'll explore these fundamental concepts of object-oriented programming and how they contribute to creating robust and maintainable code.
:::


## What is Encapsulation?

- Bundling of data and methods that operate on that data
- Restricting direct access to some of an object's components
- Prevents the accidental modification of data

::: {.notes}
Encapsulation is one of the fundamental principles of object-oriented programming. It involves bundling the data (attributes) and the methods that operate on that data within a single unit or object. This principle suggests that the internal representation of an object should be hidden from the outside and that access to an object's data should be restricted to methods of that object. This helps in preventing accidental modification of data and allows for better control over how the data is accessed and modified.
:::


## Benefits of Encapsulation

- Improves code modularity
- Helps manage complexity
- Protects the integrity of data
- Allows for code refactoring without affecting other parts

::: {.notes}
Encapsulation offers several benefits:
1. It improves code modularity by keeping related data and methods together.
2. It helps manage complexity by hiding the internal details of how an object works.
3. It protects the integrity of data by controlling how it's accessed and modified.
4. It allows for easier code refactoring because changes to the internal implementation don't affect code that uses the object.
These benefits contribute to creating more maintainable and flexible code.
:::


## Data Hiding in Python

- Python uses naming conventions for data hiding
- No strict private variables (unlike some other languages)
- Conventions signal how attributes and methods should be used

::: {.notes}
Unlike some other object-oriented languages, Python doesn't have strict private variables. Instead, it uses naming conventions to indicate how variables should be treated. These conventions are a form of data hiding, signaling to other programmers how certain attributes and methods should be used. While these conventions don't enforce strict access control, they're widely respected in the Python community.
:::


## Public Attributes

- Accessible from outside the class
- No special naming convention
- Example: `self.name = name`

::: {.notes}
Public attributes in Python are those that are intended to be accessed from outside the class. They don't have any special naming convention. For example, if we have an attribute `self.name = name` in our `__init__` method, this is considered a public attribute. It can be freely accessed and modified from outside the class. However, just because an attribute is public doesn't mean it should always be directly accessed or modified from outside the class.
:::


## Protected Attributes

- Indicated by a single underscore prefix
- Accessible, but should be treated as non-public
- Example: `self._age = age`

::: {.notes}
In Python, attributes prefixed with a single underscore (like `self._age = age`) are considered protected. This is a convention indicating that the attribute should be treated as non-public and should not be accessed directly from outside the class. However, it's important to note that this is just a convention. Python doesn't prevent you from accessing these attributes, but it's generally understood that they should be treated as internal use only.
:::


## Private Attributes

- Indicated by a double underscore prefix
- Name mangling applied
- Example: `self.__password = password`

::: {.notes}
Attributes prefixed with double underscores (like `self.__password = password`) are subject to name mangling in Python. This means Python changes the name of the variable to include the class name, making it harder (but not impossible) to access from outside the class. For example, if you have a class `User` with an attribute `__password`, Python will internally change this to `_User__password`. This provides a higher level of naming protection, useful for avoiding naming conflicts in inherited classes.
:::


## Name Mangling Example

```python
class User:
    def __init__(self, username, password):
        self.username = username
        self.__password = password

user = User("alice", "secret123")
print(user.username)  # Works fine
print(user.__password)  # Raises AttributeError
print(user._User__password)  # Works, but not recommended
```

::: {.notes}
In this example, we can see how name mangling works with private attributes. The `username` attribute is public and can be accessed directly. The `__password` attribute is private, and trying to access it directly with `user.__password` will raise an AttributeError. However, Python's name mangling means we can still access it using `user._User__password`, though this is generally not recommended as it goes against the principle of data hiding.
:::


## Getters and Setters

- Methods to access and modify attributes
- Provide controlled access to attributes
- Allow for additional logic when getting/setting values

::: {.notes}
Getters and setters are methods used to access and modify the values of attributes. They provide a level of indirection, allowing you to add logic around getting and setting values. For example, you might want to validate a value before setting it, or perform some calculation before returning a value. Using getters and setters is a common practice in many object-oriented languages, though in Python, we often use properties instead.
:::


## Properties in Python

- Built-in `@property` decorator
- Allows getter-like behavior
- `@attribute.setter` for setter behavior
- Provides clean syntax for accessing attributes

::: {.notes}
In Python, we often use properties instead of traditional getters and setters. The `@property` decorator allows you to define a method that can be accessed like an attribute. This provides a clean syntax for the user of the class, while still allowing you to add logic around getting and setting values. You can also define a setter using the `@attribute.setter` decorator. This approach adheres to the "Pythonic" principle of keeping things simple and explicit.
:::


## Property Example

```python
class User:
    def __init__(self, username, email):
        self._username = username
        self._email = email
    
    @property
    def email(self):
        return self._email
    
    @email.setter
    def email(self, new_email):
        if '@' in new_email:
            self._email = new_email
        else:
            raise ValueError("Invalid email format")

user = User("alice", "alice@example.com")
print(user.email)  # Uses the getter
user.email = "newalice@example.com"  # Uses the setter
```

::: {.notes}
In this example, we've created a `User` class with a protected `_email` attribute. We've defined a property `email` with a getter that simply returns the value of `_email`. We've also defined a setter that checks if the new email contains an '@' symbol before setting it. This allows us to add validation logic while still providing a clean interface for users of the class. They can access and modify the email as if it were a simple attribute, but behind the scenes, we're controlling how that happens.
:::


## Encapsulation Best Practices

- Use public attributes for stable APIs
- Use protected attributes for internal use
- Use private attributes to avoid name clashes
- Use properties for controlled access to attributes
- Document your class's public interface

::: {.notes}
When applying encapsulation in Python:
1. Use public attributes for parts of your API that are stable and meant to be accessed directly.
2. Use protected attributes (single underscore) for internal attributes that might be accessed by subclasses.
3. Use private attributes (double underscore) when you want to avoid name clashes in inheritance.
4. Use properties to provide controlled access to attributes, especially when you need to add logic around getting or setting values.
5. Always document your class's public interface clearly, including which attributes and methods are meant to be used by others.
Remember, the goal is to create classes that are easy to use correctly and hard to use incorrectly.
:::


## Summary

- Encapsulation bundles data and methods together
- Python uses naming conventions for data hiding
- Properties provide clean syntax for controlled attribute access
- Encapsulation improves code modularity and maintainability

::: {.notes}
To summarize, we've covered the concept of encapsulation and how it's implemented in Python:
- Encapsulation is about bundling data and the methods that operate on that data together, and controlling access to that data.
- Python uses naming conventions (no prefix, single underscore, double underscore) to indicate how attributes should be treated.
- Properties provide a Pythonic way to implement getters and setters, allowing for controlled access to attributes.
- Proper encapsulation leads to more modular, maintainable, and robust code.
Remember, while Python doesn't enforce strict private variables, following these conventions and principles can greatly improve the quality and maintainability of your code.
:::