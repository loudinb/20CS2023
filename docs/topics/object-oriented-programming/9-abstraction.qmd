# Abstraction

Abstraction focuses on **what** an object does, rather than **how** it does it.
More formally, abstraction is the process of hiding complex details from the user and exposing only the essential parts.

::: {.notes}
Like the other OOP principles, the benefits of abstraction include:

- Simplifies code readability.
- Reduces complexity.
- Enhances reusability.
- Makes code more maintainable.
:::

## Abstraction in Python

In Python, the `abc` module is used to create abstract classes. 

- **Abstract Base Class (ABC)**: To create an abstract class, you just make it a child of the `ABC` class.
  
- **Abstract Method**: You use the `@abstractmethod` decorator to declare a method that has no body—basically, you're telling the subclasses, "...you need to fill in the blanks here."


## Basic Syntax

```python
from abc import ABC, abstractmethod

# Defining an abstract class
class AbstractClassName(ABC):
    
    # Defining an abstract method
    @abstractmethod
    def abstract_method(self):
        pass
```

::: {.notes}
Creating an abstract class is like saying,  “Hey, I know what this thing should do, but I'll leave the *how* to someone else.”

- The `@abstractmethod` decorator makes sure subclasses implement that method.
- This setup is like giving instructions but not doing the actual work—your subclasses will have to roll up their sleeves and implement that method themselves.
:::


## Example: Geometric Shapes

Let's see how abstraction works with a simple example of geometric shapes.  We'll define an abstract class `Shape` with the abstract method: `area()`. Then, we'll create two concrete subclasses: `Rectangle` and `Circle`.

### Implementation {.hide}

:::: {.columns .smaller-70}

::: {.column width="50%"}
**Abstract Class**

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
```
:::

::: {.column width="50%"}
**Concrete Subclasses**

```python
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * (self.radius ** 2)
```
:::

::::



::: {.notes}

**Abstract Class**:
- `Shape` is an abstract class.
- It contains the abstract method: `area()`.
- The `@abstractmethod` decorator is used to indicate that the method must be implemented by subclasses.

**Subclasses**:
- `Rectangle` and `Circle` are concrete subclasses of `Shape`.
- They must implement the `area()` method.
:::

### Creating Objects {.hide}

We can create instances of these concrete classes and utilize their methods:

```python
rectangle = Rectangle(5, 10)
circle = Circle(7)

print(f"Rectangle Area: {rectangle.area()}")  # Rectangle Area: 50
print(f"Circle Area: {circle.area()}")        # Circle Area: 153.86
```

::: {.notes}
Each shape object behaves differently based on its own implementation, but both adhere to the same abstract interface.
:::

### Hands-On: Geometric Shapes {.hide background-color="rgb(204, 255, 255)"}

::: {.smaller-70}
1. Add an abstract method `perimeter()` in the `Shape` class.
2. Implement a `Triangle` subclass that inherits from `Shape`.
3. Ensure all shape subclasses implement the `area()` and `perimeter()` methods.
4. Add a `__str__` method to the `Shape` class that returns a formatted string with the shape, area, and perimeter (e.g., `"Rectangle: Area=50, Perimeter=30"`).

::: {.smaller-60}
| Calculation    | Right Triangle                  | Rectangle          | Circle                  |
|----------------|---------------------------------|--------------------|-------------------------|
| **Area**       | $\frac{1}{2} \times a \times b$ | $a \times b$       | $\pi \times r^2$        |
| **Perimeter**  | $a + b + \sqrt{a^2 + b^2}$      | $2 \times (a + b)$ | $2 \times \pi \times r$ |

:::
:::

### The Abstraction Advantage {.hide}

In our `Shape` example, abstraction provides the flexibility for adding new shapes (like `Triangle`), without modifying the existing code.

- The `Shape` class defines the "what" (calculate area, perimeter) without specifying the "how".
- `Rectangle`, `Circle` and `Triangle` provide their own implementations of "how" to calculate the area.
- Users can work with different shapes through a common interface.

::: {.notes}
Standard methods provide a basic form of abstraction, OOP principles allow for more sophisticated and flexible abstractions. This can lead to more maintainable and extensible code, especially in larger and more complex systems.
:::
