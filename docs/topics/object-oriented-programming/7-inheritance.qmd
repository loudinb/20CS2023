# Inheritance

## What is Inheritance?


:::: {.columns}

::: {.column width="60%"}

Inheritance is a fundamental concept in OOP, it allows one class to inherit attributes and methods from another class. This promotes code reuse and establishes relationships between classes.

:::

::: {.column width="40%"}

![](/docs/topics/object-oriented-programming/inheritance.svg)

:::

::::


::: {.notes}
TODO: Add notes
:::

## Common Phrases {.hide}


Common phrases used to convey the relationship between the **child (subclass)** and the **parent (superclass)** in inheritance

:::: {.columns}

::: {.column width="60%"}

- A Dog **"is-a"** Animal.
- Dog class extends Animal class (by adding new methods or attributes).
- Dog is a subclass of Animal, so it inherits behavior from Animal.

:::

::: {.column width="40%"}

::: {style="padding-top:40px"}
![](/docs/topics/object-oriented-programming/inheritance-animal.svg){fig-align="center"}
:::

:::

::::

::: {.notes}
TODO: Add notes
:::


## Basic Syntax {.hide}

To define a class that **inherits** from another class, the parent class is passed as an argument in the class definition:

```python
class Parent:
    def method1(self):
        print("This is a method in the parent class.")

class Child(Parent):
    def method2(self):
        print("This is a method in the child class.")

obj = Child()
obj.method1()  # Inherited method from Parent
obj.method2()  # Method from Child
```

::: {.notes}
TODO: Add notes
:::

### Hands-On: Animals

```python
class Animal:
   def __init__(self, name):
      self.name = name

class Dog(Animal):

   def speak(self):
      return f"{self.name} says Woof!"
```



## `__init__` Method {.hide .full-width}

A child class will use it's own `__init__` constructor if it has one. If not, it will use the parent class's `__init__` constructor.

:::: {.columns .smaller-70}

::: {.column width="50%"}
```python
class Animal:

   def __init__(self, name):
      self.name = name

class Dog(Animal):

   def speak(self):
      return f"{self.name} says Woof!"

```
:::


::: {.column width="50%"}
```python
class Animal:

   def __init__(self, name):
      self.name = name


class Dog(Animal):

   def __init__(self, name, breed):
      self.name = name
      self.breed = breed

   def speak(self):
      return f"{self.name} says Woof!"
```
:::

::::

::: {.notes}
TODO: Add notes
:::


## The `super()` Function {.hide}

The **`super()`** function allows you to call methods from the parent class inside the child class. This is especially useful for extending the behavior of the parent classâ€™s methods.


```python
class Animal:

   def __init__(self, name):
      self.name = name
   

class Dog(Animal):

   def __init__(self, name, breed):
      super().__init__(name)
      self.breed = breed

   def speak(self):
      return f"{self.name} says Woof!"
```

::: {.notes}
TODO: Add notes
:::


### Hands-On: Extending Behavior

```python
class Parent:
   def __init__(self, name):
         self.name = name
   
   def display(self):
         print(f"Name: {self.name}")

class Child(Parent):
   def __init__(self, name, age):
         super().__init__(name)  # Call the parent constructor
         self.age = age
   
   def display(self):
         super().display()  # Call the parent's method
         print(f"Age: {self.age}")
```

## Types of Inheritance

### Single Inheritance  {.hide}

**Single Inheritance**: A child class inherits from one parent class.

:::: {.columns}

::: {.column width="60%"}
```python
class Parent:
    pass

class Child(Parent):
    pass
```
:::

::: {.column width="40%"}
![](/docs/topics/object-oriented-programming/inheritance-single.svg){fig-align="center"}
:::

::::

::: {.notes}
TODO: Add notes
:::

### Multiple Inheritance {.hide}

**Multiple Inheritance**: A child class inherits from multiple parent classes.

:::: {.columns}

::: {.column width="60%"}
```python
class Parent1:
    pass

class Parent2:
    pass

class Child(Parent1, Parent2):
    pass
```
:::

::: {.column width="40%"}
![](/docs/topics/object-oriented-programming/inheritance-multiple.svg){fig-align="center"}
:::

::::

::: {.notes}
TODO: Add notes
:::

### Hands-On: Multiple Inheritance

```python
class Flyer:
    def fly(self):
        return "I can fly!"

class Swimmer:
    def swim(self):
        return "I can swim!"

class Duck(Flyer, Swimmer):
    pass
```


### Multilevel Inheritance {.hide}

**Multilevel Inheritance**: A child class inherits from a parent class, and then another class can inherit from that child class, creating a chain.

:::: {.columns}

::: {.column width="60%"}
```python
class Grandparent:
    pass

class Parent(Grandparent):
    pass

class Child(Parent):
    pass
```
:::

::: {.column width="40%"}
![](/docs/topics/object-oriented-programming/inheritance-multilevel.svg){fig-align="center"}
:::

::::

::: {.notes}
TODO: Add notes
:::


### Hierarchical Inheritance {.hide}

**Hierarchical Inheritance**: Multiple child classes inherit from the same parent class.

:::: {.columns}

::: {.column width="60%"}
```python

class Parent:
    pass

class Child1(Parent):
    pass

class Child2(Parent):
    pass

class Child3(Parent):
    pass
```
:::

::: {.column width="40%"}
![](/docs/topics/object-oriented-programming/inheritance-hierarchical.svg){fig-align="center"}
:::

::::

::: {.notes}
TODO: Add notes
:::


## Access Modifiers and Inheritance

- **Public Attributes/Methods:** Inherited and can be accessed in both the parent and child classes.
- **Private Attributes/Methods:** Defined by using a double underscore prefix (`__`) and are not accessible directly from the child class. However, Python uses name mangling to allow indirect access.

```python
class Parent:
   def __init__(self):
         self.__private_var = 42
   
   def __private_method(self):
         print("This is a private method")

class Child(Parent):
   def access_private(self):
         # Cannot directly access __private_var or __private_method
         # self.__private_var  # This will raise an AttributeError
         pass
```

- **Protected Attributes/Methods:** By convention, attributes prefixed with a single underscore (`_`) are considered protected and should not be accessed directly outside the class, but can be accessed by subclasses.

```python
class Parent:
   def __init__(self):
         self._protected_var = "Protected"

class Child(Parent):
   def access_protected(self):
         print(self._protected_var)  # Accessing the protected attribute
```

::: {.notes}
TODO: Add notes
:::


## `isinstance()` and `issubclass()`

- **`isinstance()`**: Used to check if an object is an instance of a class or a subclass of that class.

```python
isinstance(obj, ParentClass)  # Returns True if obj is instance of ParentClass or a subclass
```

- **`issubclass()`**: Used to check if a class is a subclass of another class.

```python
issubclass(ChildClass, ParentClass)  # Returns True if ChildClass is a subclass of ParentClass
```

::: {.notes}
TODO: Add notes
:::


## Method Resolution Order (MRO)

- Python follows the **Method Resolution Order (MRO)** to determine the order in which base classes are searched when looking for a method.

- You can check the MRO of a class by inspecting its `__mro__` attribute or using the `mro()` method.

```python
print(Child.mro())  # Displays the method resolution order
```

- This is particularly important in **multiple inheritance** scenarios (where C3 linearization algorithm is used to resolve method lookup).

::: {.notes}
TODO: Add notes
:::

## Inheritance and Composition

- **Inheritance**: "is-a" relationship
- **Composition**: "has-a" relationship
- Composition often provides more flexibility than inheritance

![](/docs/topics/object-oriented-programming/inheritance-vs-composition.svg){fig-align="center"}

::: {.notes}
TODO: Add notes
:::


### Hands-On: Inheritance and Composition

```python
# Inheritance
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def bark(self):
        return f"{self.name} says Woof!"

# Composition
class Engine:
    def start(self):
        return "Engine started"

class Car:
    def __init__(self):
        self.engine = Engine()
    
    def start_car(self):
        return self.engine.start()
```