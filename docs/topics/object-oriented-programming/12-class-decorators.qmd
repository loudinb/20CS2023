# Class Decorators

- Class decorators are functions that modify or enhance classes
- They are applied using the `@decorator` syntax above class definitions
- Similar to function decorators, but work on classes

## Basic Structure of a Class Decorator

```python
def my_decorator(cls):
    # Modify or enhance the class
    return cls

@my_decorator
class MyClass:
    pass
```

- The decorator function takes a class as an argument
- It returns the modified class


## Adding Methods

Let's create a decorator that adds a method to a class:

```python
def add_greeting(cls):
    def say_hello(self):
        return f"Hello from {self.__class__.__name__}"
    cls.say_hello = say_hello
    return cls

@add_greeting
class Person:
    def __init__(self, name):
        self.name = name

p = Person("Alice")
print(p.say_hello())  # Output: Hello from Person
```

## Logging Class Creation

We can use a decorator to log when classes are created:

```python
def log_creation(cls):
    print(f"Class {cls.__name__} has been created!")
    return cls

@log_creation
class Car:
    def __init__(self, model):
        self.model = model

# Output: Class Car has been created!
c = Car("Tesla")
```

## Singleton Pattern

Class decorators can implement design patterns like Singleton:

```python
def singleton(cls):
    instances = {}
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class DatabaseConnection:
    def __init__(self):
        print("Initializing database connection")

db1 = DatabaseConnection()  # Prints: Initializing database connection
db2 = DatabaseConnection()  # No output, same instance returned
print(db1 is db2)  # Output: True
```