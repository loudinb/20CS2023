# @property Decorator


::: {.notes}
Recall that a decorator is a function that modifies another function or class. The `@property` decorator is a built-in Python decorator that allows you to define a method that can be accessed like an attribute. This provides a clean and intuitive way to manage attribute access in classes.
:::

## Overview

- What is `@property`?
- Why use `@property`?
- Basic Usage
- Data Validation
- Read-Only and Computed Properties
- Lazy Evaluation
- Best Practices

::: {.notes}
In this session, we'll delve into the `@property` decorator, a powerful feature in Python that provides control over attribute access in classes. We'll cover its various use cases, including data validation and lazy evaluation.
:::

---

## What is `@property`?

- `@property` allows methods to be accessed like attributes.
- It enables controlled access to instance data.
- Useful for adding logic during attribute access.

Example:
```python
class User:
    def __init__(self, username):
        self._username = username
    
    @property
    def username(self):
        return self._username

user = User("pythonista")
print(user.username)  # Output: pythonista
```

::: {.notes}
The `@property` decorator allows a method to be accessed like an attribute. Here, `username` can be accessed using `user.username` instead of `user.username()`.
:::

---

## Why Use `@property`?

- **Encapsulation**: Control access to private attributes.
- **Validation**: Validate data before setting an attribute.
- **Readability**: Use method-like attributes to keep the code clean.

::: {.notes}
`@property` is particularly useful for encapsulating private attributes, validating data, and improving the readability of your code. It provides a clean interface to manage attribute access.
:::

---

## Basic Usage of `@property`

### Getter and Setter

```python
class User:
    def __init__(self, username):
        self._username = username
    
    @property
    def username(self):
        return self._username
    
    @username.setter
    def username(self, value):
        if len(value) < 3:
            raise ValueError("Username must be at least 3 characters long")
        self._username = value

user = User("dev_guru")
user.username = "coder"  # This works
# user.username = "a"  # Raises ValueError
```

::: {.notes}
In this example, `@property` is used to create a getter and setter for the `username` attribute. The setter includes validation to ensure the username is at least 3 characters long.
:::

---

## Read-Only Properties

### Creating Read-Only Attributes

```python
class User:
    def __init__(self, username):
        self._username = username
    
    @property
    def username(self):
        return self._username

user = User("readonly_user")
print(user.username)  # Output: readonly_user
# user.username = "new_user"  # Raises AttributeError
```

::: {.notes}
To create a read-only property, simply define the `@property` getter without a corresponding setter. In this example, `username` can be read but not modified directly.
:::

---

## Computed Properties

### Using `@property` to Compute Values

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    @property
    def area(self):
        return self.width * self.height

rect = Rectangle(10, 20)
print(rect.area)  # Output: 200
```

::: {.notes}
The `area` property in the `Rectangle` class is computed dynamically based on the width and height. This allows you to present calculated values as attributes.
:::

---

## Lazy Evaluation with `@property`

### Deferring Expensive Calculations

```python
class DataFetcher:
    def __init__(self):
        self._data = None
    
    @property
    def data(self):
        if self._data is None:
            print("Fetching data...")
            self._data = [1, 2, 3]  # Simulate expensive operation
        return self._data

fetcher = DataFetcher()
print(fetcher.data)  # Fetches data
print(fetcher.data)  # Uses cached data
```

::: {.notes}
Lazy evaluation with `@property` helps defer expensive operations until the attribute is accessed. In this example, data is fetched only when needed and then cached.
:::

---

## Best Practices and Common Pitfalls

- **Use for Controlled Access**: Apply `@property` when access to an attribute needs control.
- **Avoid Overuse**: Don't use `@property` for every attribute; use it judiciously.
- **Clear Naming**: Use intuitive names for properties to enhance code readability.

::: {.notes}
While `@property` is powerful, it's important to use it judiciously. Use it for controlled access to attributes, and avoid using it for trivial cases where direct attribute access is sufficient.
:::

---

## Summary

- **`@property`**: Provides controlled access to attributes.
- **Validation**: Use setters for data validation.
- **Computed Properties**: Define attributes that are computed on the fly.
- **Lazy Evaluation**: Defer expensive operations until the attribute is accessed.

::: {.notes}
In summary, `@property` is a versatile tool in Python for managing attribute access, ensuring data integrity, and simplifying your codebase. Use it to enhance encapsulation, validation, and code readability.
:::

---

## Practical Exercise

### Create a `BankAccount` Class

1. Implement a `BankAccount` class with:
   - A private `_balance` attribute.
   - A `balance` property to access it.
   - A `balance` setter to ensure balance cannot be negative.
2. Add a method to deposit and withdraw funds using the property.

::: {.notes}
Try to create a `BankAccount` class that uses `@property` to control the access and modification of the account balance, ensuring it remains consistent and valid.
:::
