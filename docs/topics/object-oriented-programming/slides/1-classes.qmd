# Classes

A class is a blueprint for creating objects.

- Bundles data (attributes) and functionality (methods) together
- Creates a new custom type that can be used to create instances (objects)


::: {.notes}
A class in Python is a user-defined blueprint or prototype from which objects are created. It provides a means of bundling data and functionality together. When you create a class, you're essentially creating a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state and methods for modifying its state or performing operations.
:::


## Documentation References

The following links are references to the Python documentation relevant to the topics discussed here:

- [Classes](https://docs.python.org/3/tutorial/classes.html)

:::{.notes}
As always, you should become familiar with the official Python documentation. It is an invaluable resource for learning more about the language and its features.
:::

## Why Use Classes?

::: {.smaller-80}
```python
users = [
 ["bangbangnyc", "tattoo artist to the stars", 150],
 ["whymykidwascrying", "turning crying fits into humor", 230],
 ["textsfromyourex", "sharing texts from exes", 100],
 # ... more users
]

def add_post(user_index):
    users[user_index][2] += 1

def get_post_count(user_index):
    return users[user_index][2]
```

Issues with this approach:

- Lack of clarity
- Difficult to add new attributes
- Disconnected functionality
- Hard to manage as complexity grows
:::

::: {.notes}
To understand why classes are valuable, consider a scenario where we need to manage user data and associated behaviors.
Without classes, we might use a list to store user data and separate functions to manipulate that data. This approach has several drawbacks:

- Lack of clarity: It's not immediately clear what each element in the list represents.
- Difficulty in adding new attributes: Adding a new attribute requires modifying every entry.
- Prone to errors: It's easy to mix up the order of attributes or insert incorrect data types.
- Disconnected functionality: Functions that operate on user data are separate from the data itself, making the code less intuitive and harder to maintain.
- Scalability issues: As the system grows with more attributes and functions, it becomes increasingly difficult to manage and understand the relationships between data and functionality.

Classes solve these problems by creating a custom data structure that bundles related data and functions together, providing a more organized and intuitive way to manage complex systems.
:::


## Class Definition {.hide}

::: {.smaller-80}
The basic syntax for defining a class in Python:  

```python
class ClassName:
    def __init__(self, arg1, arg2, ...):
        self.attribute1 = arg1
        self.attribute2 = arg2
        # ...
    
    def method1(self, ...):
        # method definition
```

Key points:

- Use class keyword to create a class
- __init__ method initializes new instances
- self refers to the instance being created
- Attributes: Variables that store data for each instance
- Methods: Functions defined within the class that operate on instance data
- Both attributes and methods defined with self. are public by default
:::

::: {.notes}
In Python, a class is defined using the class keyword. The class body contains attributes and methods.

Attributes are variables that belong to each instance of the class. They represent the state or properties of an object. In this example, username, bio, and posts are attributes.

Methods are functions defined within the class. They define the behaviors or actions that objects of the class can perform. Here, add_post() and get_post_count() are methods.

The __init__ method is a special method called when an object is created, used to initialize the object's attributes.

The self parameter represents the instance of the class and must be the first parameter of any method.

Both attributes and methods defined in a class are public by default in Python:
:::


## Public vs. Private

There's no strict enforcement of public and private access. Naming conventions are used to indicate the intended visibility of attributes and methods.

::: {.notes}
In Python, the concept of public and private members is more a matter of convention than strict enforcement:  

- Python follows a philosophy of "we're all consenting adults here," trusting developers to respect the intended usage rather than enforcing strict access control. 
:::

### Public

```python
class User:
    def __init__(self, username):
        self.username = username  # Public attribute

    def get_username(self):       # Public method
        return self.username
```

- Accessible from outside the class
- Default for attributes and methods
- Named without leading underscores

::: {.notes}
Public members:
- Are the default in Python
- Can be accessed from outside the class
- Are named without any leading underscores
- Example: `user.username` or `user.get_username()`
:::

### Private (by convention)

```python
class User:
    def __init__(self, username):
        self.__username = username  # "Private" attribute

    def __get_username(self):       # "Private" method
        return self.__username
```

- Intended for internal use only
- Prefix with double underscores
- Name mangling applied

::: {.notes}
Private members:
- Are intended for internal use within the class
- Are prefixed with double underscores (e.g., `__private_attr`)
- Undergo name mangling (e.g., `__private_attr` becomes `_ClassName__private_attr`)
- Can still be accessed, but it's harder and considered bad practice
- Example: `user._User__username` (accessing "private" attribute, not recommended)
:::


::: {.notes}
The use of single underscores (e.g., `_semi_private`) is a convention to indicate that an attribute or method is intended for internal use, but doesn't invoke name mangling.

Remember, true private access doesn't exist in Python. The double underscore convention is a way to make it harder to access these members, but not impossible.
:::