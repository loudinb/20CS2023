# Advanced Instance Attributes and Methods

## Beyond Basic Attributes and Methods 

- Special methods (dunder methods)
- Interdependent attributes
- Properties
- Bound vs unbound methods

::: {.notes}
We'll explore advanced concepts in Object-Oriented Programming (OOP) using Python, building upon the basics of instance attributes and methods. Examples will be drawn from a `User` class, inspired by an Instagram-like application, to illustrate these concepts.
:::

---

## Special Methods (Dunder Methods)

Customize object behavior with Python's built-in functions and operators.

Example: `__str__` method

```python
class User:
    def __init__(self, username, followers=0):
        self.username = username
        self.followers = followers
    
    def __str__(self):
        return f"@{self.username} ({self.followers} followers)"

user = User("python_lover", 1000)
print(str(user))  # Output: @python_lover (1000 followers)
```

::: {.notes}
Special methods, also known as "dunder" methods, allow us to define how objects interact with Python's built-in functions and operators. The `__str__` method controls how the object is represented as a string, influencing functions like `print()` and `str()`.
:::

---

## More Special Methods

Use `__repr__` for detailed representation:

```python
class User:
    def __init__(self, username, followers=0):
        self.username = username
        self.followers = followers
    
    def __repr__(self):
        return f"User(username='{self.username}', followers={self.followers})"

user = User("python_lover", 1000)
print(repr(user))  # Output: User(username='python_lover', followers=1000)
```

::: {.notes}
The `__repr__` method provides a detailed and unambiguous representation of the object, mainly for debugging and logging. Ideally, `__repr__` should return a string that, when passed to `eval()`, recreates the object.
:::

---

## Operator Overloading

Use `__add__` for custom addition behavior:

```python
class User:
    def __init__(self, username, followers=0):
        self.username = username
        self.followers = followers
    
    def __add__(self, other):
        return User(f"{self.username}_{other.username}", 
                    self.followers + other.followers)
    
    def __str__(self):
        return f"@{self.username} ({self.followers} followers)"

user1 = User("python_lover", 1000)
user2 = User("code_ninja", 2000)
collab_user = user1 + user2
print(collab_user)  # Output: @python_lover_code_ninja (3000 followers)
```

::: {.notes}
Operator overloading enables custom behaviors for built-in operators. Here, we've defined what it means to "add" two `User` objects, creating a new collaborative user account with combined usernames and follower counts.
:::

---

## Callable Objects

Make an object callable with the `__call__` method:

```python
class FollowerTracker:
    def __init__(self, user):
        self.user = user
    
    def __call__(self, increment):
        self.user.followers += increment
        return self.user.followers

user = User("insta_star", 5000)
tracker = FollowerTracker(user)
print(tracker(100))  # Output: 5100
print(tracker(50))   # Output: 5150
```

::: {.notes}
The `__call__` method allows an object to be used as if it were a function. In this example, `FollowerTracker` updates and returns the follower count whenever it is called.
:::

---

## Interdependent Attributes

Manage attributes that depend on each other:

```python
class User:
    def __init__(self, username, posts=0, avg_likes=0):
        self.username = username
        self._posts = posts
        self._avg_likes = avg_likes
        self._total_likes = posts * avg_likes
    
    def add_post(self, likes):
        self._posts += 1
        self._total_likes += likes
        self._update_avg_likes()
    
    def _update_avg_likes(self):
        if self._posts > 0:
            self._avg_likes = self._total_likes / self._posts
```

::: {.notes}
When attributes depend on one another, they must be kept in sync. Here, the `User` class ensures the average likes are updated whenever a new post is added, maintaining consistency between posts, total likes, and average likes.
:::

---

## Properties

Use the `@property` decorator for getter and setter methods:

```python
class User:
    def __init__(self, username):
        self._username = username
    
    @property
    def username(self):
        return self._username
    
    @username.setter
    def username(self, value):
        if len(value) < 3:
            raise ValueError("Username must be at least 3 characters long")
        self._username = value

user = User("py_lover")
print(user.username)  # Output: py_lover
user.username = "code_ninja"  # This works
# user.username = "a"  # This raises ValueError
```

::: {.notes}
Properties allow attributes to be managed with getter and setter methods. They offer a way to add logic during the attribute's access or modification while maintaining a clean interface for the users of the class.
:::

---

## Bound vs Unbound Methods

### Bound Methods

```python
user = User("python_guru")
post_method = user.add_post
post_method(100)  # This works, 'user' is implicitly passed
```

### Unbound Methods

```python
unbound_post_method = User.add_post
# unbound_post_method(100)  # This fails
unbound_post_method(user, 100)  # This works, we explicitly pass 'user'
```

::: {.notes}
Bound methods are tied to a specific instance and receive the instance (`self`) as the first argument automatically. Unbound methods are associated with the class and require the instance to be explicitly passed. Bound methods are more commonly used in practice.
:::
