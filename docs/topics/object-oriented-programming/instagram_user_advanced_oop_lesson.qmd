
---

---

## Advanced Lesson Overview
- **Objective**: Expand on OOP concepts using an Instagram-like User system.
- **Topics**:
  1. Error Handling and Validation
  2. Data Privacy and Properties
  3. Static Methods
  4. Deep Copy and Cloning
  5. Composition (Profile Management)
  6. Observer Pattern (Follower Notifications)
  7. Context Managers (Temporary Changes)
  8. Saving and Loading State (Persistence)
  9. Testing the User Class

---

## 1. Error Handling and Validation
- Use exceptions to handle errors and validate data.

```python
class User:
    def __init__(self, username, bio):
        self.username = username
        self.bio = bio
        self.posts = []
        self.__followers = []
        self.following = []

    def create_post(self, image_url, caption):
        if not image_url or not caption:
            raise ValueError("Image URL and caption cannot be empty.")
        post = {"image_url": image_url, "caption": caption}
        self.posts.append(post)
        return f"{self.username} posted: {caption}"

    def follow(self, other_user):
        if self == other_user:
            raise ValueError("A user cannot follow themselves.")
        if other_user not in self.following:
            self.following.append(other_user)
            other_user.__add_follower(self)
            return f"{self.username} is now following {other_user.username}"
        return f"{self.username} is already following {other_user.username}"

    def __add_follower(self, user):
        if user not in self.__followers:
            self.__followers.append(user)

# Error handling examples
try:
    user1.follow(user1)
except ValueError as e:
    print(e)  # Output: A user cannot follow themselves.
```

---

## 2. Data Privacy and Properties
- Use properties to safely expose private data.

```python
class User:
    def __init__(self, username, bio):
        self.username = username
        self.bio = bio
        self.__followers = []

    @property
    def followers(self):
        # Return a copy of the followers list to prevent modification
        return self.__followers[:]

    @property
    def follower_count(self):
        return len(self.__followers)

# Accessing followers safely
print(user1.follower_count)  # Output: 0
```

---

## 3. Static Methods
- Use static methods for utility functions not tied to an instance.

```python
class User:
    @staticmethod
    def is_valid_username(username):
        # Simple validation: must be alphanumeric and at least 3 characters long
        return username.isalnum() and len(username) >= 3

# Using static method
print(User.is_valid_username("adventure_lover"))  # Output: True
```

---

## 4. Deep Copy and Cloning
- Use deep copy to clone objects.

```python
class User:
    def clone(self):
        import copy
        return copy.deepcopy(self)

# Cloning a user
user_clone = user1.clone()
print(user_clone)  # Output: User(username='adventure_lover', bio='...')
```

---

## 5. Composition (Profile Management)
- Use composition to include a `Profile` class within `User`.

```python
class Profile:
    def __init__(self, bio, profile_pic_url=None):
        self.bio = bio
        self.profile_pic_url = profile_pic_url

class User:
    def __init__(self, username, bio):
        self.username = username
        self.profile = Profile(bio)

    def update_bio(self, new_bio):
        self.profile.bio = new_bio

# Using composition
user1.update_bio("New adventures await! ðŸŒ„")
print(user1.profile.bio)  # Output: New adventures await! ðŸŒ„
```

---

## 6. Observer Pattern (Follower Notifications)
- Notify users of changes using a simple observer pattern.

```python
class User:
    def __add_follower(self, user):
        if user not in self.__followers:
            self.__followers.append(user)
            self.notify_new_follower(user)

    def notify_new_follower(self, user):
        print(f"{self.username}, you have a new follower: {user.username}!")

# Observing new followers
user2 = User("nature_photographer", "Capturing the beauty of nature ðŸ“¸")
user1.follow(user2)  # Output: nature_photographer, you have a new follower: adventure_lover!
```

---

## 7. Context Managers (Temporary Changes)
- Use context managers for temporary changes.

```python
from contextlib import contextmanager

class User:
    @contextmanager
    def temporary_bio_change(self, new_bio):
        old_bio = self.profile.bio
        self.profile.bio = new_bio
        yield
        self.profile.bio = old_bio

# Using context manager for temporary bio change
with user1.temporary_bio_change("Temporary bio for an event"):
    print(user1.profile.bio)  # Output: Temporary bio for an event
print(user1.profile.bio)  # Output: New adventures await! ðŸŒ„
```

---

## 8. Saving and Loading State (Persistence)
- Serialize and deserialize user data.

```python
import json

class User:
    def to_dict(self):
        return {
            "username": self.username,
            "bio": self.profile.bio,
            "posts": self.posts,
            "followers_count": self.follower_count
        }

    def to_json(self):
        return json.dumps(self.to_dict())

    @staticmethod
    def from_json(json_data):
        data = json.loads(json_data)
        user = User(data['username'], data['bio'])
        user.posts = data['posts']
        return user

# Saving and loading state
user_data = user1.to_json()
loaded_user = User.from_json(user_data)
```

---

## 9. Testing the User Class
- Use `unittest` to validate the behavior of the class.

```python
import unittest

class TestUser(unittest.TestCase):
    def test_follow(self):
        user1 = User("user1", "Bio1")
        user2 = User("user2", "Bio2")
        user1.follow(user2)
        self.assertEqual(user2.follower_count, 1)

    def test_create_post(self):
        user = User("user", "Bio")
        user.create_post("http://example.com/photo.jpg", "Caption")
        self.assertEqual(len(user.posts), 1)

if __name__ == '__main__':
    unittest.main()
```

---

## Lesson Summary
- **Advanced OOP**: Error handling, data privacy, static methods, deep copy, composition, observer pattern, context managers, persistence, and testing.
- **Next Steps**: Apply these concepts to more complex systems for robust OOP design.
