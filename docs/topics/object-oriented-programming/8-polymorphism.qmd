# Polymorphism

## What is Polymorphism?

Poly means many, and morph means forms. Polymorphism is a core concept in object-oriented programming that allows objects of different types to respond to the same method call.

- Ability of objects of different types to respond to the same method call
- Allows for flexible and generic programming
- Enables code to work with objects of multiple classes

::: {.notes}
TODO: Add notes
:::


## Behavior-Driven Polymorphism {.hide}

::: {.smaller-80}

Duck Typing is a concept in Python where objects are evaluated based on their behavior rather than their type, this can be seen as **behavior-driven polymorphism**.

::: {style="text-align: center; font-style: italic;"}
“If it walks like a duck and quacks like a duck, it’s probably a duck.”
:::

- **Behavior over inheritance**: Objects can be used as long as they provide the required methods, regardless of their class or type.
:::

::: {.smaller-60}
```python
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

class Duck:
    def speak(self):
        return "Quack!"

def make_speak(animal):
    print(animal.speak())

make_speak(Dog())   # Output: Woof!
make_speak(Cat())   # Output: Meow!
make_speak(Duck())  # Output: Quack!
```
:::

::: {.notes}

Duck typing is central to Python’s dynamic nature. It enables objects to be used based on their methods and behaviors without needing to belong to a specific class - this is a key aspect of polymorphism in Python.

1. **Behavior over Type**: Objects are evaluated by what they can **do**, not what they **are**.
2. **Polymorphism without Inheritance**: Unrelated classes like `Dog`, `Cat`, and `Duck` can all work with the same function as long as they provide the `speak()` method.
3. **Runtime Flexibility**: Python checks if the required method exists at **runtime**, not at compile time.
4. **Advantages**: Encourages flexibility and reusable code without requiring strict class hierarchies.
:::

### Hands-On: Duck Typing

What happens?

```python
class Dog:
   def speak(self):
      return "Woof!"

class Cat:
   def speak(self):
      return "Meow!"

class Starfish:
   pass

def make_speak(animal):
   print(animal.speak())

make_speak(Dog())      
make_speak(Cat())      
make_speak(Starfish())
```

::: {.notes}
This is duck typing in action because:

- The function make_speak doesn't care about the specific class of the object, just that the object can perform the required action (in this case, calling speak()).
- It is an example of dynamic polymorphism because different types of objects (e.g., Dog, Cat, etc.) are treated uniformly (i.e., they are passed to make_speak) based on the fact that they implement a specific method (speak()), not based on their class or type.
- There's no need for explicit type checks, inheritance, or interfaces.
- As long as the object behaves like a "duck" (has the method speak()), it works. If not, an error occurs at runtime.

_Note: In Python, methods are considered a type of attribute. When you try to access an attribute (whether it’s a variable or a method) that doesn’t exist, Python raises an AttributeError._
:::

## Method Overriding {.hide}

**Method overriding** is a form of polymorphism that allows a subclass to provide a specific implementation of a method that is already defined in its superclass.

::: {.smaller-90}
For example, this child class redefines the `speak` method inherited from the parent class:

```python
class Animal:

   def __init__(self, name):
      self.name = name

   def speak(self):
      return f"{self.name} makes a generic animal sound."

class Dog(Animal):

   def speak(self):
      return f"{self.name} says Woof!"

class Cat(Animal):

   def speak(self):
      return f"{self.name} says Meow!"
```
:::


::: {.notes}
TODO: Add notes
:::


### Hands-On: Method Overriding


```python
class Animal:

   def __init__(self, name):
      self.name = name

   def speak(self):
      return f"{self.name} makes a generic animal sound."

class Dog(Animal):

   def speak(self):
      return f"{self.name} says Woof!"

class Cat(Animal):

   def jump(self):
      return f"{self.name} jumps high!"
```


## Operator Overloading {.hide}

**Operator Overloading** is a form of polymorphism that allows custom classes to define how built-in operators work with their objects.

- Customizing how built-in operators work with user-defined classes
- Implemented using special method names (dunder methods)

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    
    def __str__(self):
        return f"({self.x}, {self.y})"

p1 = Point(1, 2)
p2 = Point(3, 4)
p3 = p1 + p2

print(p3)  # Output: (4, 6)
```

::: {.notes}
TODO: Add notes
:::

### Hands-On: Operator Overloading

::: {.smaller-90}
```python
class Potion:
    def __init__(self, name, power_level):
        self.name = name
        self.power_level = power_level

    def __mul__(self, other):
        # Overload the * operator to mix two potions and increase power
        if isinstance(other, Potion):
            combined_name = f"{self.name}-{other.name} Elixir"
            combined_power = self.power_level + other.power_level
            return Potion(combined_name, combined_power)
        raise ValueError("Can only mix with another Potion!")

    def __repr__(self):
        return f"Potion: {self.name}, Power Level: {self.power_level}"

# Create two potions
healing_potion = Potion("Healing", 50)
strength_potion = Potion("Strength", 70)

# Mix two potions using the overloaded * operator
super_potion = healing_potion * strength_potion
```
:::


## Method Overloading

Method overloading is a form of polymorphism that allows a class to define multiple methods with the same name but different parameter lists.


### Statically Typed Languages

In statically typed languages like C and C++, method overloading is resolved at compile time based on the method signature -- multiple functions with the same name but different parameter lists:

```c
int add(int a, int b) {
    return a + b;
}

int add(int a, int b, int c) {
    return a + b + c;
}
```

::: {.notes}
Mentioning this to contrast with Python's approach to method overloading.
:::

### In Python

Python doesn't support traditional method overloading, but it can be achieved through default arguments or variable-length arguments.

```python
class Calculator:
    def add(self, a, b=0, c=0):
        return a + b + c

calc = Calculator()
print(calc.add(1))        # Output: 1
print(calc.add(1, 2))     # Output: 3
print(calc.add(1, 2, 3))  # Output: 6
```

::: {.notes}
This example demonstrates how method overloading can be achieved in Python using default arguments, allowing a single method to handle different numbers of parameters.

Pythonic Approach:
- This approach to method overloading aligns well with Python's philosophy of simplicity and flexibility.


Considerations:
- Can make the method's behavior less obvious at first glance.
- Requires clear documentation to explain the different ways the method can be used.
- For more complex cases, you might use separate methods with descriptive names.
:::