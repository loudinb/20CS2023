# Context Managers

Context managers allow for the proper acquisition and release of resources, such as file handling, by ensuring resources are properly cleaned up (e.g., closing a file after use). 

## The `with` Statement

The `with` statement is a Pythonic way to handle resources effectively.

**Example**:
```python
with open('example.txt', 'w') as f:
    f.write('Hello, World!')
# File is automatically closed after this block
```

For custom context managers, you can use the `contextlib` library:

```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    file = open(filename, mode)
    try:
        yield file
    finally:
        file.close()

with file_manager('example.txt', 'w') as f:
    f.write('Hello, World!')
```



## Debugging

### Understanding the Stack

When an exception occurs, Python generates a **traceback** showing the call stack, which helps you trace where the error occurred in your code.

**Example**:
```python
def foo():
    return bar()

def bar():
    return baz()

def baz():
    raise ValueError("Something went wrong")

try:
    foo()
except ValueError as e:
    import traceback
    print("Traceback:")
    print(traceback.format_exc())
```

This traceback gives you details about which functions were called and where the error originated.

### Using the Python Debugger (pdb)

Python’s built-in debugger, `pdb`, is a powerful tool for interactively stepping through code, inspecting variables, and diagnosing issues.

**Example**:
```python
import pdb

def complex_function(x, y):
    result = x + y
    pdb.set_trace()  # Pauses execution here and opens the debugger
    return result * 2

complex_function(3, 4)
```

Key `pdb` commands:
- `n`: Execute the next line of code.
- `s`: Step into a function call.
- `p`: Print the value of a variable.
- `c`: Continue execution until the next breakpoint.

### Logging for Debugging

The `logging` module allows you to record and track the behavior of your program at different logging levels, which is often more scalable than using `print` statements.

**Example**:
```python
import logging

logging.basicConfig(level=logging.DEBUG)

def calculate_average(numbers):
    logging.debug(f"Calculating average of {numbers}")
    if not numbers:
        logging.warning("Empty list provided")
        return 0
    return sum(numbers) / len(numbers)

print(calculate_average([1, 2, 3, 4, 5]))
print(calculate_average([]))
```



## Best Practices

### Be Specific in Catching Exceptions

It’s important to catch only the exceptions that you expect and know how to handle. Catching broad exceptions or using a bare `except` clause can mask unexpected errors, making debugging more difficult and possibly hiding bugs.

**Bad** (Bare `except` clause):
```python
try:
    # risky_function()
    pass
except:
    pass  # Silently ignores all errors
```

**Good** (Catching specific exceptions):
```python
try:
    value = int(input("Enter a number: "))
    result = 10 / value
except (ValueError, ZeroDivisionError) as e:
    print(f"Invalid input: {e}")
```

**Explanation**:
- Avoid catching all exceptions with a bare `except` clause. This can mask other issues in the code, making it difficult to identify the root cause of errors.
- Instead, catch specific exceptions like `ValueError`, `ZeroDivisionError`, or others that you can properly handle.

### Use the `else` Clause

The `else` clause in a `try` block executes only if no exceptions are raised. It helps to separate the error-handling logic from the normal execution flow.

**Example**:
```python
def perform_calculation(x, y):
    return x / y

try:
    result = perform_calculation(10, 2)
except ZeroDivisionError:
    print("Cannot divide by zero")
else:
    print(f"Calculation successful. Result: {result}")
finally:
    print("Calculation attempt completed")
```

### Raise Exceptions at the Appropriate Level

If a function cannot handle an exception, raise it at an appropriate level so that the calling function can handle it.

**Example**:
```python
class DatabaseError(Exception):
    pass

def query_database():
    try:
        raise ConnectionError("Connection failed")
    except (ConnectionError, TimeoutError) as e:
        raise DatabaseError("Database operation failed") from e

try:
    query_database()
except DatabaseError as e:
    print(f"Database error: {e}")
    print(f"Original error: {e.__cause__}")
```

## Summary

- Exception handling is critical for building robust Python applications.
- Use `try/except` blocks to handle exceptions, and only catch specific exceptions.
- Create custom exceptions for clearer and more specific error reporting.
- Use context managers (`with` statements) to manage resources.
- Employ debugging tools like `pdb` and logging to troubleshoot issues efficiently.
- Follow best practices to write clean, maintainable, and