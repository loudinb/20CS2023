# Exception Handling

**Exceptions** are runtime errors that interrupt the normal flow of a program. Unhandled exceptions will cause the program to terminate.  **Exception handling** allows a program to continue running or exit gracefully when an exception occurs. 

## Python Documentation

- [Built-in exceptions](https://docs.python.org/3/library/exceptions.html)
- [Exception hierarchy](https://docs.python.org/3.12/library/exceptions.html#exception-hierarchy)
- [Raising exceptions](https://docs.python.org/3/tutorial/errors.html#raising-exceptions)

## Exception Handling Mechanism {.hide}

Python's exception handling mechanism is the `try`/`except` model.

::: {.smaller-80}

::: {.r-stack}
```{.python}
try:
    # some code
except:
    # handle exception
else:
    # execute if no exception
finally:
    # cleanup code
```
::: {.fragment .fade-in-then-out .absolute .top-0 .left-0 width="100%"}
```{.python code-line-numbers="1-2"}
try:
    # some code
except:
    # handle exception
else:
    # execute if no exception
finally:
    # cleanup code
```
**`try`: Block**

- Contains the code that might raise an exception.
- If an exception is raised within this block, control will immediately pass to the `except` block.
:::

::: {.fragment .fade-in-then-out .absolute .top-0 .left-0 width="100%"}
```{.python code-line-numbers="3-4"}
try:
    # some code
except:
    # handle exception
else:
    # execute if no exception
finally:
    # cleanup code
```
**`except:` Block**

- Contains the code to handle the exception if one occurs.

:::

::: {.fragment .fade-in-then-out .absolute .top-0 .left-0 width="100%"}
```{.python code-line-numbers="5-6"}
try:
    # some code
except:
    # handle exception
else:
    # execute if no exception
finally:
    # cleanup code
```
**`else:` Block** (_optional_)

- This block runs only if no exceptions are raised in the `try` block.
- It allows you to execute code that should only happen when the `try` block was successful, allowing the `try` block to only contain the code that could raise an exception.
:::

::: {.fragment .fade-in-then-out .absolute .top-0 .left-0 width="100%"}
```{.python code-line-numbers="7-8"}
try:
    # some code
except:
    # handle exception
else:
    # execute if no exception
finally:
    # cleanup code
```
**`finally:` Block** (_optional_)

- This block will always execute after the `try` and `except` blocks, regardless of whether an exception was raised or not.
- Itâ€™s typically used for cleanup operations like closing files, releasing resources, or undoing partial changes.

:::

:::


:::

### Catching Exceptions {.hide}

The generic `except` block will catch all errors -- this is not recommended.  Always catch specific exceptions.

::: {.r-stack}

```{.python code-line-numbers="3-5"}
try:
    # some code
except:
    # handle exceptions
    # even those you didn't expect -- this is bad practice
```

::: {.fragment .fade-in-then-out .absolute width="100%"}
```{.python code-line-numbers="1-5"}
try:
    import math
    math.sqrt(-1)
except ValueError:
    print("ValueError")
```
`ValueError`: Raised when a function receives an inappropriate value.
:::

::: {.fragment .fade-in-then-out .absolute width="100%"}
```{.python code-line-numbers="1-4"}
try:
    1 / 0
except ZeroDivisionError:
    print("ZeroDivisionError")


```
`ZeroDivisionError`: Raised when dividing by zero.
:::

::: {.fragment .fade-in-then-out .absolute width="100%"}
```{.python code-line-numbers="1-4"}
try:
    int("abc")
except TypeError:
    print("TypeError")


```
`TypeError`: Raised when performing invalid operations between incompatible types.
:::

::: {.fragment .fade-in-then-out .absolute width="100%"}
```{.python code-line-numbers="1-5"}
list = [1, 2, 3]
try:
    list[3]
except IndexError:
    print("IndexError")
```
`IndexError`: Raised when accessing an index that is out of range.
:::

::: {.fragment .fade-in-then-out .absolute width="100%"}
```{.python code-line-numbers="1-5"}
dict = {"name": "Jane"}
try:
    dict["email"]
except KeyError:
    print("KeyError")
```
`KeyError`: Raised when accessing a non-existent dictionary key.
:::

:::



### Catching Multiple Exceptions {.hide}

You can handle multiple exceptions by adding multiple `except`.

```{.python code-line-numbers="6,9"}
def process_data(data):
    try:
        value = int(data)
        result = 100 / value
        return result
    except ValueError:
        print("Invalid data: cannot convert to integer")
        return None
    except ZeroDivisionError:
        print("Invalid data: cannot divide by zero")
        return None
```


### Grouping Exceptions {.hide}

You can group exceptions into a single `except` block using parentheses.  This is useful when you want to handle multiple exceptions in the same way.

```{.python code-line-numbers="5"}
def divide_numbers(a, b):
    try:
        result = a / b
        return result
    except (ValueError, TypeError, ZeroDivisionError):
        print(f"An error occurred.")
        return None
```

::: {.notes}
Grouping exceptions can be useful when you need to handle multiple different exceptions in the same way. It helps keep the code cleaner and reduces redundancy. An example where grouping exceptions makes sense is a mathemetical operation that involves type mismatches and mathematical operations that are invalid.
:::


### The `as` Keyword {.hide}

:::{.smaller-80}

The `as` keyword in exception handling allows you to capture the raised exception object, giving you access to its details.

```python
try:
    # Some code that might raise an exception
    result = 10 / 0
except ZeroDivisionError as e:
    print(f"Error occurred: {e}")
    print(f"Error type: {type(e).__name__}")
```

**Key points:**

- `as e` assigns the exception object to the variable `e` (can be any valid variable name, but `e` is commonly used)
- Provide access to exception attributes like:
  - `e.__class__`: The exception's class
  - `str(e)`: The exception's message
- Useful for:
  - Logging detailed error information
  - Conditional handling based on exception details
  - Re-raising exceptions with additional context
:::

::: {.notes}
```python
try:
    with open("nonexistent_file.txt", "r") as file:
        content = file.read()
except OSError as e:
    print(f"Type: {type(e)}")
    print(f"Args: {e.args}")
    print(f"Errno: {e.errno}")
    print(f"Strerror: {e.strerror}")
    print(f"Filename: {e.filename}")
```
:::

### Precedence Rules for Return Statements {.hide}

::: {.smaller-85}
Precendence rules for return statements in exception handling blocks:
:::

::: {.smaller-60}

| Block    | Execution Condition | Return Behavior | Notes |
|----------|---------------------|-----------------|-------|
| `try`     | Always attempts to execute | If it contains a `return` statement, this value is returned (unless overridden by `finally`) | |
| `except`  | Executes if an exception occurs in `try` | If it contains a `return` statement, this value is returned (unless overridden by `finally`) | |
| `else`    | Executes if `try` completes without an exception and without executing a `return` | If it contains a `return` statement, this value is returned (unless overridden by `finally`) | Does not execute if `try` has already executed a `return` statement |
| `finally` | Always executes if present | **Overrides** all other `return` statements | Executes regardless of whether a `return` statement was encountered in other blocks. |

: {tbl-colwidths="[15,25,30,30]"}

:::


### Raising Exceptions {.hide}

:::{.smaller-90}
You can manually raise exceptions using the `raise` keyword. This is useful for enforcing application-specific constraints or when detecting an error condition that Python's built-in checks don't cover.

```{.python}
def validate_age(age):
    if not isinstance(age, (int, float)):
        raise TypeError("Age must be a number")
    if age < 0:
        raise ValueError("Age cannot be negative")
    return age

try:
    validate_age(-5)
except (ValueError, TypeError):
    print(f"Validation error")
```
:::

### User-Defined Exceptions {.hide}

:::{.smaller-80}
**User-defined exceptions** can be created by subclassing the built-in `Exception` class or its subclasses. These are beneficial when you need more specific error signaling that standard exceptions don't adequately cover.


```python
class InsufficientFundsError(Exception):
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        super().__init__(f"Insufficient funds: balance {balance}, required {amount}")
```

- This class extends `Exception` to create a new type of error.
- The `super().__init__()` call ensures proper initialization of the base `Exception` class.
- Custom attributes (`balance` and `amount`) provide more context for the error.

:::


### Implementing and Handling Custom Exceptions

:::{.smaller-70}
**Example Usage:**

```python
def withdraw(balance, amount):
    if balance < amount:
        raise InsufficientFundsError(balance, amount)
    return balance - amount

try:
    withdraw(100, 150)
except InsufficientFundsError as e:
    print(f"Transaction failed: {e}")
    print(f"Current balance: {e.balance}")
    print(f"Attempted withdrawal: {e.amount}")
```

**Best Practices:**

1. Derive custom exceptions from Python's built-in exceptions when appropriate (e.g., `ValueError`, `TypeError`).
2. Use descriptive names for custom exceptions (e.g., `InsufficientFundsError` instead of `MyError`).
3. Include relevant error information in the exception message and as attributes.
4. Document your custom exceptions, especially if they're part of a library or API.

:::

:::{.notes}
**Key Points:**
- The `withdraw` function raises `InsufficientFundsError` if the amount exceeds the balance.
- In the `except` block, we can access the custom attributes of our exception.
:::

### When to Use Custom Exceptions {.hide}

:::{.smaller-85}
::: {.callout-note}
Built-in exceptions often suffice for most situations. Use custom exceptions sparingly, only when they significantly improve error handling, enhance code clarity, or provide crucial domain-specific information.
:::

**When to Use Custom Exceptions?**

- Improved specificity: Define error types directly meaningful to your application.
- Enhanced readability: Distinct exception types aid in debugging and error handling.
- Better context: Custom attributes can carry additional information about the error.
- Clearer error messages: Provide more informative feedback to users or logging systems.
:::
