### Question 171 {.question}

What is this type of evaluation between `x` and `y` called?

```python
x = 1
y = 1
if x and y:
    print("both true")
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] Short-circuit evaluation
- [ ] Shortcut evaluation
- [ ] Lazy evaluation
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] Short-circuit evaluation
- [ ] Shortcut evaluation
- [ ] Lazy evaluation


::: {.explanation}
Short-circuit evaluation means that the second condition is evaluated only if the first condition is not enough to determine the result.
:::
:::
:::

### Question 172 {.question}

We _________ objects from a class to create concrete instances with specific attribute values.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] instantiate
- [ ] concatenate
- [ ] interpret
- [ ] syscall
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] instantiate
- [ ] concatenate
- [ ] interpret
- [ ] syscall


::: {.explanation}
To create a concrete instance of a class, we instantiate the class, assigning specific values to the object's attributes.
:::
:::
:::

### Question 173 {.question}

Anonymous functions in Python are defined with what keyword?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `def`
- [ ] `anon`
- [ ] `lambda`
- [ ] `fun`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `def`
- [ ] `anon`
- [x] `lambda`
- [ ] `fun`


::: {.explanation}
In Python, anonymous functions are created using the `lambda` keyword.
:::
:::
:::

### Question 174 {.question}

What is the technique called when some arguments of a function are fixed?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] Partial application
- [ ] Semi function
- [ ] Static argumentation
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] Partial application
- [ ] Semi function
- [ ] Static argumentation


::: {.explanation}
Partial application refers to fixing some arguments of a function, producing a new function with fewer arguments.
:::
:::
:::

### Question 175 {.question}

::: {.smaller-70}
Match the list operation to its action:

- `list.append(x)`
- `list.pop()`
- `list.remove(x)`

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] Adds x to the end of the list, Removes the last element of the list, Removes the first item from the list whose value is x
- [ ] Removes the last element of the list, Adds x to the end of the list, Removes the first item from the list whose value is x
- [ ] Removes the first item from the list whose value is x, Removes the last element of the list, Adds x to the end of the list
- [ ] Adds x to the end of the list, Removes the first item from the list whose value is x, Removes the last element of the list
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] Adds x to the end of the list, Removes the last element of the list, Removes the first item from the list whose value is x
- [ ] Removes the last element of the list, Adds x to the end of the list, Removes the first item from the list whose value is x
- [ ] Removes the first item from the list whose value is x, Removes the last element of the list, Adds x to the end of the list
- [ ] Adds x to the end of the list, Removes the first item from the list whose value is x, Removes the last element of the list


::: {.explanation}
- `list.append(x)` adds `x` to the end of the list.
- `list.pop()` removes and returns the last element of the list.
- `list.remove(x)` removes the first occurrence of `x` from the list.
:::
:::
:::
:::

### Question 176 {.question}

What is the result of the following code?

```python
numbers = [10, 20, 30]
numbers.append(40)
print(numbers)
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `[10, 20]`
- [ ] `[10, 20, 30]`
- [x] `[10, 20, 30, 40]`
- [ ] `[40, 10, 20, 30]`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `[10, 20]`
- [ ] `[10, 20, 30]`
- [x] `[10, 20, 30, 40]`
- [ ] `[40, 10, 20, 30]`


::: {.explanation}
The `append()` method adds `40` to the end of the list, so the result is `[10, 20, 30, 40]`.
:::
:::
:::

### Question 177 {.question}

Which of the following expressions will raise a `TypeError`?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `"5" + "6"`
- [ ] `5 + 6`
- [ ] `"5" * 3`
- [ ] `"5" + 6`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `"5" + "6"`
- [ ] `5 + 6`
- [ ] `"5" * 3`
- [x] `"5" + 6`


::: {.explanation}
The expression `"5" + 6` will raise a `TypeError` because Python does not allow the concatenation of a string and an integer without explicit conversion.
:::
:::
:::

### Question 178 {.question}

Which of the following methods modify a list in place? (Select all that apply)

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `sort()`
- [ ] `reverse()`
- [ ] `append()`
- [ ] `extend()`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] `sort()`
- [x] `reverse()`
- [x] `append()`
- [x] `extend()`


::: {.explanation}
All of these methods—`sort()`, `reverse()`, `append()`, and `extend()`—modify the list in place without creating a new list object.
:::
:::
:::

### Question 179 {.question}

Which statement expresses that a function maps elements from the domain to the range?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `f: D→R`
- [ ] `f(D,R)`
- [ ] `f: D==R`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] `f: D→R`
- [ ] `f(D,R)`
- [ ] `f: D==R`


::: {.explanation}
The mathematical notation `f: D→R` indicates that the function `f` maps elements from the domain `D` to the range `R`.
:::
:::
:::

### Question 180 {.question}

The `break` statement skips the rest of the current iteration and moves to the next iteration.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] True
- [ ] False
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] True
- [x] False


::: {.explanation}
The `break` statement exits the loop entirely, while the `continue` statement skips the rest of the current iteration and moves to the next one.
:::
:::
:::

