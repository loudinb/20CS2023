### Question 121 {.question}

Static methods can access or modify class state.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] True
- [ ] False
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] True
- [x] False


::: {.explanation}
Static methods cannot access or modify class or instance state since they do not take `self` or `cls` as arguments.
:::
:::
:::

### Question 122 {.question}

Will the variable `x` have different memory addresses before and after modification in the following scenario?

```python
x = 5
print(id(x))
x = x + 1
print(id(x))
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] Yes
- [ ] No
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] Yes
- [ ] No


::: {.explanation}
When you assign a new value to `x`, the memory address changes because integers are immutable in Python. Reassigning a variable creates a new object.
:::
:::
:::

### Question 123 {.question}

To access an element of a vector, we need one index, while an element of a matrix is addressed by two indexes.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] True
- [ ] False
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] True
- [ ] False


::: {.explanation}
In a vector (1D list), a single index is used, while a matrix (2D list) requires two indices: one for the row and one for the column.
:::
:::
:::

### Question 124 {.question}

What do we call the function inside a decorator called?

The ________ function.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] Inner
- [ ] Decorated
- [ ] Wrapper
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] Inner
- [ ] Decorated
- [x] Wrapper

::: {.explanation}
The function inside a decorator is called the "wrapper" function because it wraps around the original function to add extra functionality.
:::
:::
:::

### Question 125 {.question}

Which of the following expressions will return `True`?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `5 == "5"`
- [ ] `"Hello" == "hello"`
- [ ] `5 != 6`
- [ ] `3 >= 5`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `5 == "5"`
- [ ] `"Hello" == "hello"`
- [x] `5 != 6`
- [ ] `3 >= 5`


::: {.explanation}
The expression `5 != 6` is `True` because 5 is not equal to 6. All other expressions are `False` due to case sensitivity or mismatched types.
:::
:::
:::

### Question 126 {.question}

What is the result of the following code?

```python
numbers = [1, 2, 3, 4, 5]
numbers.pop(2)
print(numbers)
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `[1, 2, 3, 4, 5]`
- [ ] `[1, 3, 4, 5]`
- [ ] `[1, 2, 4, 5]`
- [ ] `[1, 2, 3, 5]`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `[1, 2, 3, 4, 5]`
- [ ] `[1, 3, 4, 5]`
- [x] `[1, 2, 4, 5]`
- [ ] `[1, 2, 3, 5]`


::: {.explanation}
The `pop(2)` method removes the element at index 2, which is `3`. The list becomes `[1, 2, 4, 5]`.
:::
:::
:::

### Question 127 {.question}

::: {.smaller-80}
Which statement correctly squares `my_investments` resulting in the output `rich = [250000, 1, 40000, 22090000]`?

```python
money_in_stocks = [500, 1, 200, 4700]
stock_tickers = ['TSLA', 'ME', 'ADBE']
combined = list(zip(money_in_stocks, stock_tickers))
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `rich = [i[0]**2 for i in combined]`
- [ ] `rich = [i**2 for x[0] in combined]`
- [ ] `rich = [i[0]^2 for i in combined]`
- [ ] `rich = [i^2 for x[0] in combined]`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] `rich = [i[0]**2 for i in combined]`
- [ ] `rich = [i**2 for x[0] in combined]`
- [ ] `rich = [i[0]^2 for i in combined]`
- [ ] `rich = [i^2 for x[0] in combined]`


::: {.explanation}
The correct list comprehension is `rich = [i[0]**2 for i in combined]`, which squares the first element (stock prices) of each tuple in `combined`.
:::
:::
:::
:::


### Question 128 {.question}

The Python interpreter executes code line by line, rather than compiling the entire program at once.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] True
- [ ] False
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] True
- [ ] False


::: {.explanation}
Python is an interpreted language, meaning the interpreter reads and executes code line by line, as opposed to compiled languages that translate the entire program into machine code before execution.
:::
:::
:::

### Question 129 {.question}

Which of the following is NOT a way to run Python code?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] Using the interactive shell
- [ ] Running a `.py` file from the command line
- [ ] Using an Integrated Development Environment (IDE)
- [ ] Compiling Python code into a standalone executable
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] Using the interactive shell
- [ ] Running a `.py` file from the command line
- [ ] Using an Integrated Development Environment (IDE)
- [x] Compiling Python code into a standalone executable


::: {.explanation}
Python is an interpreted language, and it is not typically compiled into standalone executables. Instead, Python scripts are executed directly by the interpreter.
:::
:::
:::

### Question 130 {.question}

Which of the following are true about the bolded line of code? (Select all that apply)

```python
instance_of_Fungi_class = Fungi("Agaricus", "bisporus")
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] This is object instantiation
- [ ] The `__init__` function is invoked
- [ ] You forgot to explicitly pass `self`. It should be `tasty_fungus = Fungi(self, "Agaricus", "bisporus")`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] This is object instantiation
- [x] The `__init__` function is invoked
- [ ] You forgot to explicitly pass `self`. It should be `tasty_fungus = Fungi(self, "Agaricus", "bisporus")`


::: {.explanation}
The bolded line of code creates a new instance of the `Fungi` class, invoking the `__init__` method. There is no need to pass `self` explicitly, as it is automatically handled by Python.
:::
:::
:::

