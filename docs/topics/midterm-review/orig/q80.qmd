### Question 81 {.question}

::: {.smaller-80}
Match the operator to the description:

- `<=`
- `!=`
- `==`
- `>`

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] Less than or equal to; Not equal to; Equal to; Greater than
- [ ] Not equal to; Less than or equal to; Equal to; Greater than
- [ ] Equal to; Greater than; Less than or equal to; Not equal to
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] Less than or equal to; Not equal to; Equal to; Greater than
- [ ] Not equal to; Less than or equal to; Equal to; Greater than
- [ ] Equal to; Greater than; Less than or equal to; Not equal to


::: {.explanation}
The correct matching is: `<=` means "less than or equal to", `!=` means "not equal to", `==` means "equal to", and `>` means "greater than".
:::
:::
:::
:::

### Question 82 {.question}

Fill in the missing parameter in the method definition.

```python
class Fungi:
    def add_fungus(_______, fungus_species):
        self.favorite_fungi[fungus_species] = "added"
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `fungi`
- [ ] `self`
- [ ] `cls`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `fungi`
- [x] `self`
- [ ] `cls`


::: {.explanation}
The first parameter of instance methods must be `self`, which refers to the current instance of the class.
:::
:::
:::

### Question 83 {.question}

Which of the following is a correct way to iterate through a list in Python?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `for i in range(list):`
- [ ] `for i in len(list):`
- [ ] `for i in list:`
- [ ] `while i in list:`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `for i in range(list):`
- [ ] `for i in len(list):`
- [x] `for i in list:`
- [ ] `while i in list:`


::: {.explanation}
The correct syntax for iterating through each element in a list is `for i in list:` where `i` will represent each element of the list in each iteration.
:::
:::
:::

### Question 84 {.question}

The `%` operator is the preferred way to format strings in Python.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] True
- [ ] False
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] True
- [x] False


::: {.explanation}
The preferred way to format strings in modern Python is to use f-strings or the `format()` method. The `%` operator is considered outdated and less flexible.
:::
:::
:::

### Question 85 {.question}

Which of the following operations will return the first character of the string `text = "hello"`?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `text[1]`
- [ ] `text[0]`
- [ ] `text[-1]`
- [ ] `text[:1]`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `text[1]`
- [x] `text[0]`
- [ ] `text[-1]`
- [ ] `text[:1]`


::: {.explanation}
The expression `text[0]` returns the first character of the string `"hello"`, which is `"h"`. The slice `text[:1]` also works but includes slicing instead of direct indexing.
:::
:::
:::

### Question 86 {.question}

::: {.smaller-80}
You donâ€™t know how many people will attend your club meeting, but you want to make a record of who attended by passing names through your function. Fill in the blank to unpack the arguments.

```python
def record_attendance(meeting_date, *__________):
    print(f"Meeting date: {meeting_date}")
    print("People who attended:", __________)
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `names`
- [ ] `args`
- [ ] `kwargs`
- [ ] `participants`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `names`
- [x] `args`
- [ ] `kwargs`
- [ ] `participants`


::: {.explanation}
The `*args` syntax allows you to pass a variable number of positional arguments to the function. The variable `args` will hold all the passed names.
:::
:::
:::
:::

### Question 87 {.question}

Global variables should be avoided because they can make code harder to maintain.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] True
- [ ] False
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] True
- [ ] False


::: {.explanation}
Global variables can make code harder to maintain and debug because their values can be changed from anywhere in the program, leading to unpredictable behavior.
:::
:::
:::

### Question 88 {.question}

To indicate that a method is a class method, what is the decorator line that precedes the method definition?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `@staticmethod`
- [ ] `@property`
- [ ] `@classmethod`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `@staticmethod`
- [ ] `@property`
- [x] `@classmethod`


::: {.explanation}
The `@classmethod` decorator is used to define a class method in Python. It modifies the method to take the class itself as the first argument (`cls`).
:::
:::
:::

### Question 89 {.question}

Which of the following are reasons to use a class method? (Select all that apply)

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] When you want the method to be able to modify the class state
- [ ] When the method is creating instances (factory method)
- [ ] When defining instance attributes
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] When you want the method to be able to modify the class state
- [x] When the method is creating instances (factory method)
- [ ] When defining instance attributes


::: {.explanation}
Class methods are useful when you need to modify class state or create new instances (factory methods), but they are not typically used for defining instance attributes.
:::
:::
:::

### Question 90 {.question}

The function `___________()` can be used to call methods from the superclass.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `super()`
- [ ] `base()`
- [ ] `parent()`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] `super()`
- [ ] `base()`
- [ ] `parent()`


::: {.explanation}
The `super()` function allows you to call methods from the superclass, enabling access to inherited methods and attributes.
:::
:::
:::

