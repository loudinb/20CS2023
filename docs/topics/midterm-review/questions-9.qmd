## Question 1 {.question}

True or False: The `super()` function allows a child class to access methods from its parent class, including the constructor.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] True
- [ ] False
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] True
- [ ] False

::: {.explanation}
The `super()` function is used to call methods from a parent class, including the `__init__` constructor, allowing the child class to extend or modify the behavior of the parent class.
:::

:::

:::



## Question 2 {.question}

Which of the following is an example of **multiple inheritance**?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] A child class inherits from a single parent class.
- [ ] A class inherits from both `Parent1` and `Parent2`.
- [ ] A class inherits from a child class, which in turn inherits from a grandparent class.
- [ ] A class has multiple methods, each performing a different function.
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] A child class inherits from a single parent class.
- [x] A class inherits from both `Parent1` and `Parent2`.
- [ ] A class inherits from a child class, which in turn inherits from a grandparent class.
- [ ] A class has multiple methods, each performing a different function.

::: {.explanation}
Multiple inheritance occurs when a class inherits from more than one parent class, allowing it to combine the behavior and properties of multiple classes.
:::

:::

:::



## Question 3 {.question}

What will be the result of the following code?

```python
class Parent:
    def __init__(self):
        self.value = "Parent value"

    def show(self):
        print(self.value)

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.value = "Child value"

obj = Child()
obj.show()
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `"Parent value"`
- [ ] `None`
- [ ] `"Child value"`
- [ ] `Error`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `"Parent value"`
- [ ] `None`
- [x] `"Child value"`
- [ ] `Error`

::: {.explanation}
The `Child` class calls the `__init__` method of the `Parent` class using `super()` and then overrides `self.value` to `"Child value"`. Therefore, `obj.show()` prints `"Child value"`.
:::

:::

:::



## Question 4 {.question}

Which statement about **protected attributes** in Python is correct?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] Protected attributes are defined using a double underscore (`__`) prefix.
- [ ] Protected attributes are indicated by a single underscore (`_`) prefix and are accessible within subclasses.
- [ ] Protected attributes cannot be accessed by any other classes, including subclasses.
- [ ] Protected attributes are the same as public attributes.
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] Protected attributes are defined using a double underscore (`__`) prefix.
- [x] Protected attributes are indicated by a single underscore (`_`) prefix and are accessible within subclasses.
- [ ] Protected attributes cannot be accessed by any other classes, including subclasses.
- [ ] Protected attributes are the same as public attributes.

::: {.explanation}
Protected attributes are conventionally indicated by a single underscore (`_`). They are accessible within the class and subclasses, but not intended to be accessed from outside.
:::

:::

:::



## Question 5 {.question}

What does the term **polymorphism** refer to in object-oriented programming?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] The ability of a child class to override methods from the parent class.
- [ ] The ability of different classes to be used interchangeably if they implement the same interface or method.
- [ ] The process of creating a new class from an existing class.
- [ ] The process of restricting access to certain methods and attributes.
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] The ability of a child class to override methods from the parent class.
- [x] The ability of different classes to be used interchangeably if they implement the same interface or method.
- [ ] The process of creating a new class from an existing class.
- [ ] The process of restricting access to certain methods and attributes.

::: {.explanation}
Polymorphism allows different classes to be treated as if they were of the same type, as long as they implement the required methods. This supports flexibility and reusability in the code.
:::

:::

:::



## Question 1 {.question}

True or False: The `__new__` method in Python is responsible for creating a new instance of a class, while `__init__` initializes it.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] True
- [ ] False
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] True
- [ ] False

::: {.explanation}
The `__new__` method is responsible for creating a new instance of a class, whereas `__init__` initializes that instance. This is why `__new__` is called before `__init__`.
:::

:::

:::



## Question 2 {.question}

Which of the following statements about the `__str__` and `__repr__` methods is correct?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `__str__` should return a detailed and unambiguous representation of the object.
- [ ] `__repr__` is called by the `print()` function.
- [ ] `__str__` provides a user-friendly representation of the object, while `__repr__` provides a more detailed representation for debugging.
- [ ] Both `__str__` and `__repr__` serve the same purpose and return identical results.
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `__str__` should return a detailed and unambiguous representation of the object.
- [ ] `__repr__` is called by the `print()` function.
- [x] `__str__` provides a user-friendly representation of the object, while `__repr__` provides a more detailed representation for debugging.
- [ ] Both `__str__` and `__repr__` serve the same purpose and return identical results.

::: {.explanation}
`__str__` is intended to provide a user-friendly representation of the object, often used by `print()`, whereas `__repr__` is aimed at giving an unambiguous and detailed representation suitable for debugging.
:::

:::

:::



## Question 3 {.question}

What is the primary use of the `__call__` method in a Python class?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] To make an object callable like a function.
- [ ] To initialize object attributes.
- [ ] To manage context using the `with` statement.
- [ ] To compare two objects for equality.
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] To make an object callable like a function.
- [ ] To initialize object attributes.
- [ ] To manage context using the `with` statement.
- [ ] To compare two objects for equality.

::: {.explanation}
The `__call__` method allows an instance of a class to be called as if it were a function. This is useful for creating callable objects, such as decorators or instances that need to behave like functions.
:::

:::

:::



## Question 4 {.question}

What will be the output of the following code?

```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor

    def __call__(self, x):
        return x * self.factor

double = Multiplier(2)
print(double(10))
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `20`
- [ ] `Error: Multiplier object is not callable`
- [ ] `2`
- [ ] `None`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] `20`
- [ ] `Error: Multiplier object is not callable`
- [ ] `2`
- [ ] `None`

::: {.explanation}
The `__call__` method allows the `Multiplier` object `double` to be called like a function, multiplying `10` by the factor (`2`) and resulting in `20`.
:::

:::

:::



## Question 5 {.question}

Which of the following describes the lifecycle stages of an object in Python?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] Creation, Assignment, Initialization, Deletion
- [ ] Instantiation, Usage, Inheritance, Destruction
- [ ] Creation (`__new__`), Initialization (`__init__`), Usage, Destruction (`__del__`)
- [ ] Memory Allocation, Usage, Copying, Deletion
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] Creation, Assignment, Initialization, Deletion
- [ ] Instantiation, Usage, Inheritance, Destruction
- [x] Creation (`__new__`), Initialization (`__init__`), Usage, Destruction (`__del__`)
- [ ] Memory Allocation, Usage, Copying, Deletion

::: {.explanation}
The lifecycle of an object includes `Creation` managed by `__new__`, `Initialization` handled by `__init__`, `Usage` where the object's methods are called, and `Destruction`, which occurs when the object is deleted and `__del__` is invoked.
:::

:::

:::