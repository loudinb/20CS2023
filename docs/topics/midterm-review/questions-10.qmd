## Question 1 {.question}

True or False: In Python, the `finally` block always executes after the `try` and `except` blocks, regardless of whether an exception occurred.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] True
- [ ] False
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] True
- [ ] False

::: {.explanation}
The `finally` block is always executed, whether an exception occurs or not, making it useful for cleanup tasks like closing a file or releasing a resource.
:::

:::

:::



## Question 2 {.question}

Which of the following is the correct way to handle multiple exceptions in Python using a single `except` block?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `except ValueError or TypeError:`
- [ ] `except [ValueError, TypeError]:`
- [ ] `except (ValueError, TypeError):`
- [ ] `except ValueError, TypeError:`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `except ValueError or TypeError:`
- [ ] `except [ValueError, TypeError]:`
- [x] `except (ValueError, TypeError):`
- [ ] `except ValueError, TypeError:`

::: {.explanation}
To handle multiple exceptions in a single block, enclose them in parentheses, like `except (ValueError, TypeError):`. This syntax allows the block to handle any of the listed exceptions.
:::

:::

:::



## Question 3 {.question}

What will be the output of the following code?

```python
def test_function(value):
    try:
        if value == 0:
            raise ValueError("An error occurred!")
        return "From try block"
    except ValueError:
        return "From except block"
    finally:
        return "From finally block"

print(test_function(1))
print(test_function(0))
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `"From try block"` followed by `"From except block"`
- [ ] `"From finally block"` followed by `"From finally block"`
- [ ] `"From try block"` followed by `"From finally block"`
- [ ] `"From except block"` followed by `"From finally block"`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `"From try block"` followed by `"From except block"`
- [x] `"From finally block"` followed by `"From finally block"`
- [ ] `"From try block"` followed by `"From finally block"`
- [ ] `"From except block"` followed by `"From finally block"`

::: {.explanation}
The `finally` block always overrides the return value from both `try` and `except` blocks. Therefore, `"From finally block"` is returned in both cases.
:::

:::

:::



## Question 4 {.question}

Which keyword is used to manually raise an exception in Python?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `throw`
- [ ] `raise`
- [ ] `except`
- [ ] `catch`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `throw`
- [x] `raise`
- [ ] `except`
- [ ] `catch`

::: {.explanation}
The `raise` keyword is used in Python to manually raise an exception. This is useful for enforcing constraints or creating custom error conditions.
:::

:::

:::



## Question 5 {.question}

What is the role of the `__enter__` and `__exit__` methods in custom context managers?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] They are used to initialize and finalize the program, respectively.
- [ ] They manage the acquisition and release of resources in the context manager.
- [ ] They handle exceptions within the context manager.
- [ ] They serve the same purpose as `try` and `except` blocks.
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] They are used to initialize and finalize the program, respectively.
- [x] They manage the acquisition and release of resources in the context manager.
- [ ] They handle exceptions within the context manager.
- [ ] They serve the same purpose as `try` and `except` blocks.

::: {.explanation}
The `__enter__` method is called at the start of a `with` block to acquire resources, and `__exit__` is called at the end to release resources, ensuring proper cleanup.
:::

:::

:::



## Question 1 {.question}

True or False: In Python's logging module, the `FileHandler` is used to log messages to a file, creating a new file if it does not already exist.

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] True
- [ ] False
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [x] True
- [ ] False

::: {.explanation}
The `FileHandler` sends log messages to a specified file, and it creates a new file if it does not already exist.
:::

:::

:::



## Question 2 {.question}

Which logging level would you use if you want to indicate a condition that might cause a problem but does not necessarily stop the program?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] DEBUG
- [ ] INFO
- [ ] WARNING
- [ ] ERROR
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] DEBUG
- [ ] INFO
- [x] WARNING
- [ ] ERROR

::: {.explanation}
The `WARNING` level indicates a condition that is unexpected or might cause a problem but does not prevent the program from running.
:::

:::

:::



## Question 3 {.question}

What will be the output if the following code is executed?

```python
import logging

logging.basicConfig(level=logging.ERROR, format="%(levelname)s: %(message)s")

logging.info("This is an informational message.")
logging.error("This is an error message.")
```

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] `INFO: This is an informational message.`
- [ ] `ERROR: This is an error message.`
- [ ] Both messages will be printed.
- [ ] Nothing will be printed.
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] `INFO: This is an informational message.`
- [x] `ERROR: This is an error message.`
- [ ] Both messages will be printed.
- [ ] Nothing will be printed.

::: {.explanation}
The logging level is set to `ERROR`, which means only messages of level `ERROR` or higher will be logged. Therefore, only `"This is an error message."` will be printed.
:::

:::

:::



## Question 4 {.question}

Which of the following statements about handlers in the Python logging module is **not** true?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] A `StreamHandler` sends log messages to the console.
- [ ] A `FileHandler` sends log messages to a file.
- [ ] `RotatingFileHandler` rotates the log file at a specified time interval.
- [ ] `SMTPHandler` sends log messages via email.
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] A `StreamHandler` sends log messages to the console.
- [ ] A `FileHandler` sends log messages to a file.
- [x] `RotatingFileHandler` rotates the log file at a specified time interval.
- [ ] `SMTPHandler` sends log messages via email.

::: {.explanation}
The `RotatingFileHandler` rotates the log file when it reaches a certain size, not at a specified time interval. The `TimedRotatingFileHandler` rotates the log file at a specific time interval.
:::

:::

:::



## Question 5 {.question}

How do you add a custom formatter to a handler in Python's logging system?

::: {.r-stack}

::: {.absolute .left-0 .top-0 width=100%}
- [ ] Use `handler.setLevel(formatter)`
- [ ] Use `handler.setFormatter(formatter)`
- [ ] Use `logger.addFormatter(formatter)`
- [ ] Use `formatter.addHandler(handler)`
:::

::: {.fragment .fade-in .absolute .left-0 .top-0 width=100%}
- [ ] Use `handler.setLevel(formatter)`
- [x] Use `handler.setFormatter(formatter)`
- [ ] Use `logger.addFormatter(formatter)`
- [ ] Use `formatter.addHandler(handler)`

::: {.explanation}
The `setFormatter()` method is used to add a custom formatter to a handler, which specifies the layout of the log messages.
:::

:::

:::
